<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Space Flappy - Gravity Flip</title>
  <style>
    body {
      margin: 0;
      overflow: hidden;
      background: black;
    }
    canvas {
      display: block;
    }
  </style>
</head>
<body>
<canvas id="game"></canvas>

<script>
// =============================
// 1. SETUP CANVAS
// =============================
const canvas = document.getElementById("game");
const ctx = canvas.getContext("2d");

function resizeCanvas() {
  canvas.width = window.innerWidth;
  canvas.height = window.innerHeight;
}
resizeCanvas();
window.addEventListener("resize", resizeCanvas);

// =============================
// 2. GAME VARIABLES
// =============================
const birdImg = new Image();
birdImg.src = "pixel_bird-removebg-preview.png";

const birdWidth = 90;
const birdHeight = 90;

let bird = {
  x: canvas.width / 4,
  y: canvas.height / 2,
  vy: 0
};

// Gravity mechanics
let gravity = 0.25;           // slightly lighter gravity for easier play
let gravityDirection = 1;    // 1 = down, -1 = up
const flapPower = 11;        // stronger flap power

// Pipes
let pipes = [];
const pipeWidth = 60;        // thinner pipes
const gapHeight = 400;       // bigger gap = easier
const pipeSpeed = 3.2;       // slightly slower pipes
const pipeFrequency = 2000;  // ms

let gameOver = false;

// Background
let bg = new Image();
bg.src = "space.jpg";

// Gravity flip timing
let warningMessage = "";
const gravityFlipInterval = 6000; // every 6 seconds

// Sparkle stars for space effect
let stars = Array.from({ length: 50 }, () => ({
  x: Math.random() * canvas.width,
  y: Math.random() * canvas.height,
  radius: Math.random() * 2
}));

// Start gravity flip timer
setInterval(() => {
  // 1 second before flip, show warning
  warningMessage = "⚠ Gravity Flip Incoming! ⚠";
  setTimeout(() => {
    // Flip gravity
    gravityDirection *= -1;
    gravity = 0.4 * gravityDirection;
    warningMessage = "";
  }, 1000);
}, gravityFlipInterval);

// =============================
// 3. CONTROLS
// =============================
window.addEventListener("keydown", (e) => {
  if (!gameOver) {
    if (gravityDirection === 1 && e.code === "ArrowUp") {
      bird.vy = -flapPower;
    } else if (gravityDirection === -1 && e.code === "ArrowDown") {
      bird.vy = flapPower;
    }
  }
  if (e.code === "Space" && gameOver) {
    restartGame();
  }
});

// =============================
// 4. PIPE GENERATION
// =============================
function addPipe() {
  let topHeight = Math.random() * (canvas.height - gapHeight - 150) + 50;
  pipes.push({
    x: canvas.width,
    topHeight: topHeight
  });
}
setInterval(() => {
  if (!gameOver) addPipe();
}, pipeFrequency);

// =============================
// 5. UPDATE LOGIC
// =============================
function update() {
  if (gameOver) return;

  // Bird physics
  bird.vy += gravity;
  bird.y += bird.vy;

  // Check collision with floor/ceiling
  if (bird.y - birdHeight / 2 < 0 || bird.y + birdHeight / 2 > canvas.height) {
    endGame();
  }

  // Pipes movement + collision
  for (let i = pipes.length - 1; i >= 0; i--) {
    pipes[i].x -= pipeSpeed;

    if (
      bird.x + birdWidth / 2 > pipes[i].x &&
      bird.x - birdWidth / 2 < pipes[i].x + pipeWidth
    ) {
      if (
        bird.y - birdHeight / 2 < pipes[i].topHeight ||
        bird.y + birdHeight / 2 > pipes[i].topHeight + gapHeight
      ) {
        endGame();
      }
    }

    if (pipes[i].x + pipeWidth < 0) {
      pipes.splice(i, 1);
    }
  }

  // Move stars for space effect
  stars.forEach(star => {
    star.x -= 0.5;
    if (star.x < 0) {
      star.x = canvas.width;
      star.y = Math.random() * canvas.height;
    }
  });
}

// =============================
// 6. DRAW EVERYTHING
// =============================
function draw() {
  ctx.drawImage(bg, 0, 0, canvas.width, canvas.height);

  // Stars
  ctx.fillStyle = "white";
  stars.forEach(star => {
    ctx.beginPath();
    ctx.arc(star.x, star.y, star.radius, 0, Math.PI * 2);
    ctx.fill();
  });

  // Bird
  ctx.drawImage(birdImg, bird.x - birdWidth / 2, bird.y - birdHeight / 2, birdWidth, birdHeight);

  // Pipes with metallic gradient
  for (let p of pipes) {
    let grad = ctx.createLinearGradient(p.x, 0, p.x + pipeWidth, 0);
    grad.addColorStop(0, "#555");
    grad.addColorStop(0.5, "#aaa");
    grad.addColorStop(1, "#555");

    ctx.fillStyle = grad;
    ctx.shadowColor = "cyan";
    ctx.shadowBlur = 15;

    ctx.fillRect(p.x, 0, pipeWidth, p.topHeight);
    ctx.fillRect(p.x, p.topHeight + gapHeight, pipeWidth, canvas.height - (p.topHeight + gapHeight));

    ctx.shadowBlur = 0; // reset shadow
  }

  // Warning text
  if (warningMessage) {
    ctx.fillStyle = "yellow";
    ctx.font = "48px sans-serif";
    ctx.textAlign = "center";
    ctx.fillText(warningMessage, canvas.width / 2, 100);
  }

  // Game Over text
  if (gameOver) {
    ctx.fillStyle = "white";
    ctx.font = "48px sans-serif";
    ctx.textAlign = "center";
    ctx.fillText("GAME OVER - Press SPACE to Restart", canvas.width / 2, canvas.height / 2);
  }
}

// =============================
// 7. GAME LOOP
// =============================
function gameLoop() {
  update();
  draw();
  requestAnimationFrame(gameLoop);
}
gameLoop();

// =============================
// 8. GAME OVER & RESTART
// =============================
function endGame() {
  gameOver = true;
}
function restartGame() {
  bird.y = canvas.height / 2;
  bird.vy = 0;
  pipes = [];
  gameOver = false;
  gravityDirection = 1;
 
  gravity = 0.4;
}
</script>
</body>
</html>

